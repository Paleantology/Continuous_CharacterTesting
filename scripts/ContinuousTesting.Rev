## Basic setup and helper variables

#c_chars <- readContinuousCharacterData("data/Continuous.nex")
d_chars <- readDiscreteCharacterData("data/Kammerer2019.nex")
taxa <- readTaxonData("data/Ages.csv")
moves    = VectorMoves()
monitors = VectorMonitors()

#c_chars.addMissingTaxa( taxa )
d_chars.addMissingTaxa( taxa )


n_tips <- taxa.size()
num_branches <- 2 * n_tips - 3

topology ~ dnUniformTopology(taxa)

moves.append( mvNNI(topology, weight=30) )
moves.append( mvSPR(topology, weight=20) )


for (i in 1:num_branches) {
   br_lens[i] ~ dnExponential(10.0)

   moves.append( mvScale(br_lens[i], lambda=4.0, weight=1, tune=false) )
   moves.append( mvScale(br_lens[i], lambda=0.2, weight=1, tune=false) )
   moves.append( mvScale(br_lens[i], lambda=.02, weight=1, tune=false) )
}

# tree length
TL := sum(br_lens)

fbd_tree := treeAssembly(topology, br_lens)


# Moves on the parameters to the Gamma distribution.
    alpha_morpho ~ dnUniform( 0, 1E6 )
    rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )
    moves.append(mvScale(alpha_morpho, lambda=1, weight=2.0))


    beta_scale ~ dnLognormal( 0.0, sd=2*0.587405 )
    moves.append( mvScale(beta_scale, lambda=1, weight=5.0 ) )

      cats := fnDiscretizeBeta(beta_scale, beta_scale, 7)
      for (x in 1:cats.size())
      {
        q[x] := fnF81(simplex(cats))
        }
        mat_prior <- rep(1,7)
        matrix_probs ~ dnDirichlet(mat_prior)
        moves.append( mvBetaSimplex(matrix_probs, weight=3.0) )
        moves.append( mvDirichletSimplex(matrix_probs, weight=1.5) )
        m_morph ~ dnPhyloCTMC( tree=fbd_tree,
                                    Q=q,
                                    siteRates=rates_morpho,
                                    siteMatrices=matrix_probs,
                                    type="Standard")
      m_morph.clamp(d_chars)

#sigma2_root ~ dnLoguniform(1e-3, 1)
#oves.append( mvScale(sigma2_root, weight=1.0) )

#expected_number_of_shifts <- 2
#rate_shift_probability    <- expected_number_of_shifts / num_branches

#sd = 0.578
#rate_shift_distribution = dnLognormal(-sd^2/2, sd)

#for(x in num_branches:1) {
    # draw the rate multiplier from a mixture distribution
#    branch_rate_multiplier[x] ~ dnReversibleJumpMixture(1, rate_shift_distribution, Probability(1 - rate_shift_probability) )
    # compute the rate for the branch
#    if ( fbd_tree.isRoot( fbd_tree.parent(x) ) ) {
#       branch_rates[x] := sigma2_root * branch_rate_multiplier[x]
#    } else {
#       branch_rates[x] := branch_rates[fbd_tree.parent(x)] * branch_rate_multiplier[x]
#    }
    # keep track of whether the branch has a rate shift
#    branch_rate_shift[x] := ifelse( branch_rate_multiplier[x] == 1, 0, 1 )
#    branch_rate_shift[x]
    # use reversible-jump to move between models with and without
    # shifts on the branch
#    moves.append( mvRJSwitch(branch_rate_multiplier[x], weight=1) )

    # include proposals on the rate mutliplier (when it is not 1)
#    moves.append( mvScale(branch_rate_multiplier[x], weight=1) )
#}

#num_rate_changes := sum( branch_rate_shift )

#sigma2 ~ dnLoguniform(1e-3, 1)
#moves.append( mvScale(sigma2, weight=1.0) )
#X ~ dnPhyloBrownianREML(fbd_tree, branchRates=sigma2^0.5, nSites = 23)
#X
#X.clamp(c_chars)



mymodel = model(fbd_tree)
monitors.append( mnModel(filename="output/simple_BM.log", printgen=10) )
monitors.append( mnScreen(printgen=1000)) #, sigma2) )
monitors.append(mnFile(filename="output/parted.trees", printgen=10, fbd_tree))
mymcmc = mcmc(mymodel, monitors, moves)
mymcmc.run(generations=500000)
q()
